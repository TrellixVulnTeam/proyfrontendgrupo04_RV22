import * as i0 from '@angular/core';
import { Injectable, EventEmitter, Directive, ElementRef, NgZone, Input, Output, NgModule, Optional } from '@angular/core';
import { Chart, Title, Tooltip, Filler, Legend, LineController, LineElement, PointElement, LinearScale, CategoryScale, BarController, BarElement, DoughnutController, ArcElement, RadarController, RadialLinearScale, PieController, PolarAreaController, BubbleController, ScatterController, TimeSeriesScale, defaults } from 'chart.js';
import { BehaviorSubject } from 'rxjs';
import { distinctUntilChanged } from 'rxjs/operators';
import { merge } from 'lodash-es';

import * as ɵngcc0 from '@angular/core';
class ThemeService {
    constructor() {
        this.colorschemesOptions = new BehaviorSubject(undefined);
    }
    setColorschemesOptions(options) {
        this.pColorschemesOptions = options;
        this.colorschemesOptions.next(options);
    }
    getColorschemesOptions() {
        return this.pColorschemesOptions;
    }
}
ThemeService.ɵfac = function ThemeService_Factory(t) { return new (t || ThemeService)(); };
ThemeService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ThemeService_Factory() { return new ThemeService(); }, token: ThemeService, providedIn: "root" });
ThemeService.ctorParameters = () => [];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ThemeService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();

class BaseChartDirective {
    constructor(element, zone, themeService) {
        this.element = element;
        this.zone = zone;
        this.themeService = themeService;
        this.type = 'bar';
        this.plugins = [];
        this.chartClick = new EventEmitter();
        this.chartHover = new EventEmitter();
        this.subs = [];
        this.ctx = element.nativeElement.getContext('2d');
        this.subs.push(this.themeService.colorschemesOptions
            .pipe(distinctUntilChanged())
            .subscribe(r => this.themeChanged(r)));
    }
    ngOnChanges(changes) {
        const requireRender = ['type'];
        const propertyNames = Object.getOwnPropertyNames(changes);
        if (propertyNames.some(key => requireRender.includes(key)) ||
            propertyNames.every(key => changes[key].isFirstChange())) {
            this.render();
        }
        else {
            const config = this.getChartConfiguration();
            if (this.chart) {
                Object.assign(this.chart.config.data, config.data);
                Object.assign(this.chart.config.plugins, config.plugins);
                Object.assign(this.chart.config.options, config.options);
            }
            this.update();
        }
    }
    ngOnDestroy() {
        if (this.chart) {
            this.chart.destroy();
            this.chart = void 0;
        }
        this.subs.forEach(s => s.unsubscribe());
    }
    render() {
        if (this.chart) {
            this.chart.destroy();
        }
        return this.zone.runOutsideAngular(() => this.chart = new Chart(this.ctx, this.getChartConfiguration()));
    }
    update(duration) {
        if (this.chart) {
            this.zone.runOutsideAngular(() => { var _a; return (_a = this.chart) === null || _a === void 0 ? void 0 : _a.update(duration); });
        }
    }
    hideDataset(index, hidden) {
        if (this.chart) {
            this.chart.getDatasetMeta(index).hidden = hidden;
            this.update();
        }
    }
    isDatasetHidden(index) {
        var _a, _b;
        return (_b = (_a = this.chart) === null || _a === void 0 ? void 0 : _a.getDatasetMeta(index)) === null || _b === void 0 ? void 0 : _b.hidden;
    }
    toBase64Image() {
        var _a;
        return (_a = this.chart) === null || _a === void 0 ? void 0 : _a.toBase64Image();
    }
    themeChanged(options) {
        this.themeOverrides = options;
        if (this.chart) {
            Object.assign(this.chart.config.options, this.getChartOptions());
            this.update();
        }
    }
    getChartOptions() {
        return merge({
            onHover: (event, active) => {
                if (active && !active.length) {
                    return;
                }
                this.chartHover.emit({ event, active });
            },
            onClick: (event, active) => {
                this.chartClick.emit({ event, active });
            }
        }, this.themeOverrides, this.options, {
            plugins: {
                legend: {
                    display: this.legend
                }
            }
        });
    }
    getChartConfiguration() {
        return {
            type: this.type,
            data: this.getChartData(),
            plugins: this.plugins,
            options: this.getChartOptions()
        };
    }
    getChartData() {
        return this.data ? this.data : {
            labels: this.labels || [],
            datasets: this.datasets || []
        };
    }
}
BaseChartDirective.ɵfac = function BaseChartDirective_Factory(t) { return new (t || BaseChartDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ThemeService)); };
BaseChartDirective.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: BaseChartDirective, selectors: [["canvas", "baseChart", ""]], inputs: { type: "type", plugins: "plugins", legend: "legend", data: "data", options: "options", labels: "labels", datasets: "datasets" }, outputs: { chartClick: "chartClick", chartHover: "chartHover" }, exportAs: ["base-chart"], features: [ɵngcc0.ɵɵNgOnChangesFeature] });
BaseChartDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone },
    { type: ThemeService }
];
BaseChartDirective.propDecorators = {
    type: [{ type: Input }],
    legend: [{ type: Input }],
    data: [{ type: Input }],
    options: [{ type: Input }],
    plugins: [{ type: Input }],
    labels: [{ type: Input }],
    datasets: [{ type: Input }],
    chartClick: [{ type: Output }],
    chartHover: [{ type: Output }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(BaseChartDirective, [{
        type: Directive,
        args: [{
                // eslint-disable-next-line @angular-eslint/directive-selector
                selector: 'canvas[baseChart]',
                exportAs: 'base-chart'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ThemeService }]; }, { type: [{
            type: Input
        }], plugins: [{
            type: Input
        }], chartClick: [{
            type: Output
        }], chartHover: [{
            type: Output
        }], legend: [{
            type: Input
        }], data: [{
            type: Input
        }], options: [{
            type: Input
        }], labels: [{
            type: Input
        }], datasets: [{
            type: Input
        }] }); })();

const baseColors = [
    [255, 99, 132],
    [54, 162, 235],
    [255, 206, 86],
    [231, 233, 237],
    [75, 192, 192],
    [151, 187, 205],
    [220, 220, 220],
    [247, 70, 74],
    [70, 191, 189],
    [253, 180, 92],
    [148, 159, 177],
    [77, 83, 96]
];

const ɵ0 = (context) => rgba(generateColor(context.datasetIndex), 0.4), ɵ1 = (context) => rgba(generateColor(context.datasetIndex), 1), ɵ2 = (context) => rgba(generateColor(context.datasetIndex), 1), ɵ3 = (context) => rgba(generateColor(context.datasetIndex), 0.8), ɵ4 = (context) => rgba(generateColor(context.datasetIndex), 0.6), ɵ5 = (context) => rgba(generateColor(context.datasetIndex), 1), ɵ6 = (context) => rgba(generateColor(context.datasetIndex), 0.8), ɵ7 = (context) => rgba(generateColor(context.datasetIndex), 1), ɵ8 = (context) => rgba(generateColor(context.dataIndex), 0.6), ɵ9 = (context) => rgba(generateColor(context.dataIndex), 1), ɵ10 = (context) => rgba(generateColor(context.dataIndex), 1), ɵ11 = (context) => rgba(generateColor(context.dataIndex), 0.6), ɵ12 = (context) => rgba(generateColor(context.dataIndex), 1), ɵ13 = (context) => rgba(generateColor(context.dataIndex), 0.8), ɵ14 = (context) => rgba(generateColor(context.dataIndex), 1);
const builtInDefaults = {
    datasets: {
        line: {
            backgroundColor: ɵ0,
            borderColor: ɵ1,
            pointBackgroundColor: ɵ2,
            pointBorderColor: '#fff',
            pointHoverBackgroundColor: '#fff',
            pointHoverBorderColor: ɵ3
        },
        bar: {
            backgroundColor: ɵ4,
            borderColor: ɵ5,
            hoverBackgroundColor: ɵ6,
            hoverBorderColor: ɵ7
        },
        get radar() {
            return this.line;
        },
        doughnut: {
            backgroundColor: ɵ8,
            borderColor: '#fff',
            hoverBackgroundColor: ɵ9,
            hoverBorderColor: ɵ10
        },
        get pie() {
            return this.doughnut;
        },
        polarArea: {
            backgroundColor: ɵ11,
            borderColor: ɵ12,
            hoverBackgroundColor: ɵ13,
            hoverBorderColor: ɵ14
        },
        get bubble() {
            return this.doughnut;
        },
        get scatter() {
            return this.doughnut;
        },
        get area() {
            return this.polarArea;
        }
    }
};
function rgba(colour, alpha) {
    return 'rgba(' + colour.concat(alpha).join(',') + ')';
}
function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}
function getRandomColor() {
    return [getRandomInt(0, 255), getRandomInt(0, 255), getRandomInt(0, 255)];
}
/**
 * Generate colors
 */
function generateColor(index = 0) {
    return baseColors[index] || getRandomColor();
}

Chart.register(Title, Tooltip, Filler, Legend, LineController, LineElement, PointElement, LinearScale, CategoryScale, BarController, BarElement, DoughnutController, ArcElement, RadarController, RadialLinearScale, PieController, PolarAreaController, BubbleController, ScatterController, TimeSeriesScale);
class NgChartsModule {
    constructor(config) {
        if (config === null || config === void 0 ? void 0 : config.plugins)
            Chart.register(config === null || config === void 0 ? void 0 : config.plugins);
        const ngChartsDefaults = merge(builtInDefaults, (config === null || config === void 0 ? void 0 : config.defaults) || {});
        defaults.set(ngChartsDefaults);
    }
    static forRoot(config) {
        return {
            ngModule: NgChartsModule,
            providers: [
                { provide: NgChartsConfiguration, useValue: config }
            ]
        };
    }
}
NgChartsModule.ɵfac = function NgChartsModule_Factory(t) { return new (t || NgChartsModule)(ɵngcc0.ɵɵinject(NgChartsConfiguration, 8)); };
NgChartsModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: NgChartsModule });
NgChartsModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[]] });
NgChartsModule.ctorParameters = () => [
    { type: NgChartsConfiguration, decorators: [{ type: Optional }] }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgChartsModule, [{
        type: NgModule,
        args: [{
                imports: [],
                declarations: [BaseChartDirective],
                exports: [BaseChartDirective]
            }]
    }], function () { return [{ type: NgChartsConfiguration, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgChartsModule, { declarations: [BaseChartDirective], exports: [BaseChartDirective] }); })();
class NgChartsConfiguration {
}
NgChartsConfiguration.ɵfac = function NgChartsConfiguration_Factory(t) { return new (t || NgChartsConfiguration)(); };
NgChartsConfiguration.ɵprov = i0.ɵɵdefineInjectable({ factory: function NgChartsConfiguration_Factory() { return new NgChartsConfiguration(); }, token: NgChartsConfiguration, providedIn: "root" });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgChartsConfiguration, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], null, null); })();

/*
 * Public API Surface of ng2-charts
 */

/**
 * Generated bundle index. Do not edit.
 */

export { BaseChartDirective, NgChartsConfiguration, NgChartsModule, ThemeService, baseColors };

//# sourceMappingURL=ng2-charts.js.map